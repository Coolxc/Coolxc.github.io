{"pages":[],"posts":[{"title":"About","text":"一个喜欢呱呱的优秀的杨优秀","link":"/2021/10/28/About/"},{"title":"Event","text":"Event JS除了可以影响全局应用程序的状态&amp;&amp;修改DOM，还可以注册事件（Registering event handlers） 当事件被触发时，浏览器就会执行对应的函数 event可以是 来自用户的鼠标点击、敲键盘；或者来自服务器的AJAX请求 所有事件都会被放入一个队列中（按浏览器检测到的先后顺序排列） 事件执行是单线程的，完成一个event -&gt; 出队一个event 浏览器将事件放入队列 这个操作 与 page-building和event-handling这两个阶段无关，也就是将事件放入队列与上述两个阶段可以并行运行(不同的线程) 下面两个阶段就是客户端浏览器运行一个页面的整个周期 page-building 构造DOM节点，遇到script标签则停止构造 去执行JS 当遇到＜/html＞标签时表示此阶段结束 event-handling event-hanling：event loop会轮询队头，如果队头有event，那么就调用相关的 event handler Registering event hanlersThere are two ways to register events 将函数赋值给某个属性：window.onload = function(){}、document.body.onclick = function(){} 使用内建的addEventListener方法：document.body.addEventListener(&quot;事件名，如click/mousemove&quot;, function(){...}) 将某个函数赋值给某个属性以注册事件有一个致命的缺陷：只能赋值一个函数，后赋值的会覆盖之前的 addEventListener方法则可以无限制的给属性注册事件 Summary12graph LR;队列空--&gt;event_loop轮询队头为空--&gt;产生事件--&gt;放入队列--&gt;event_loop轮询找到所有相关的event_handler--&gt;出队列--&gt;执行--&gt;队头为空或执行下一个事件; Exercises What are the two phases in the lifecycle of a client-side web application? What is the main advantage of using the addEventListener method to register an event handler versus assigning a handler to a specific element property? How many events can be processed at once? In what order are events from the event queue processed?","link":"/2021/11/13/Event/"},{"title":"newFunction","text":"🍕Today, I get a skill for sublime text3——press fn + ➡/⬅ to skip to head/end of line Let’s start with an example! 123456789101112131415161718192021222324252627282930//Cache the function result, some function need to perform the calculations, which can be time-consuming operation for larger valuesfunction isPrime(value){ if (!isPrime.answers){ isPrime.answers = {}; } if (isPrime.answers[value] !== undefined) { console.log(&quot;The answer was cached!!!---&quot; + value + &quot;is prime!!!&quot;); return isPrime.answers[value]; } var prime = value !== 1;// value !== 1; var prime=value. //It's say that the result of &quot;prime&quot; depends on &quot;value&quot; whether equal one. for (var i = 2; i &lt; value; i++){ if (value % i === 0) { prime = false; break; } } console.log(value + &quot;is prime!!!&quot;); return isPrime.answers[value] = prime;}isPrime(5);isPrime(5); 🛩BUT, But, but. Noting is perfect. ​ Any sort of caching will certainly sacrifice memory in favor of performance. Now, Let us go ahead!FunctionThere are several ways to define a function. function myFun() {return 1;} myArg =&gt; myArg*2 The arrow function (may be you can say: lambda functions) And, more on~ ES6 was a milestone for JS, which included the arrow functions. new Function(‘a’, ‘b’, ‘return a + b’) Function constructors, which creates a function with two parameters, a and b, that returns the sum of those two parameters. function* myGen() { yield 1;} Geerator functions. It’s to hard to understand!!! WTF parameter&amp;argumentIn this part, let us talk about the P&amp;A. I was very clarity about P&amp;A, I guess. 🍕So, let’s go ahead, talk about some “rediculous” things. In JS, there is very freedom to assign parameters. 123456789//For examplefunction foo(a, b, c) {...};//you can do this: foo(1, 2, 3, 4); //Yes, you can fucking input more than what you defined number of parameters. //Especially, you can find the fourth argument...(at later chapter)//as well you canfoo(1);//Yes! you can input every number of parameters you want.while the parameters b and c would be set to undefined. Arrow functionsIn this part, we will have a insight at arrow functions (actually, not “insight”🤐) No bb, Show CODE: 123456789101112131415161718var values = [0,3,5,2,4,1];var res = values.sort( (value1, value2) =&gt; value1 - value2 );console.log(res);//The parentheses is mandatory for 0 or more than 1 parameter; //opitional for 1 parametervar greet = name =&gt; &quot;Greetings &quot; + name;console.log(greet(&quot;Yang&quot;));//When we require more code, we can include a block of codevar greetWithBlockOfCode = name =&gt; { var helloString = &quot;HELLO WORLD &quot;; //If there is no return statement, //the result of the function invocation will be undefined return helloString + name; }console.log(greetWithBlockOfCode(&quot;^Y^&quot;)); We will get real insight at chapter 6 or 7 (I forget it); Let’s do it!","link":"/2021/11/22/newFunction/"},{"title":"很高兴和你相见--Secrets of the JavaScript Ninja","text":"为什么&lt;script&gt;总是放到最后当DOM渲染遇到script节点时会停止渲染 -&gt; 去加载script。如果此时 ID 为first的元素在script后面，并且此时script需要用到first元素，那么此时脚本就找不到这个元素。 script加载完毕会返回继续渲染DOM节点 script全局变量 It’s important to note that the global state of the JavaScript application persists in the meantime. All user-defined global variables created during the execution of JavaScript code in one script element are normally accessible to JavaScript code in other script elements. This happens because the global window object, which stores all global JavaScript variables, is alive and accessible during the entire lifecycle of the page. 为什么使用匿名函数Just do it! 12345678910var text = &quot;Momo&quot;;function useless(callbackFun) { console.log(&quot;In useless function&quot;); return callbackFun();}//Anonymous functionconsole.log(useless(function (){return text})); Anonymous functions can eliminate the need to pollute the global namespace with unnecessary names when a function isn’t going to be referenced from multiple places within the code.","link":"/2021/11/06/JS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"First Post","text":"老李头 我想和你吃火锅！！！","link":"/2021/10/28/First-Post/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"}],"categories":[{"name":"JS","slug":"JS","link":"/categories/JS/"}]}